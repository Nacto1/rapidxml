<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.4.7">
  <compounddef id="page1" kind="page">
    <compoundname>page1</compoundname>
    <detaileddescription>
<para><ref refid="page1_1what_is_rapidxml" kindref="member">What is RapidXml?</ref>  <linebreak/>
<linebreak/>
 </para><sect1 id="page1_1what_is_rapidxml">
<title>What is RapidXml?</title>
<para><heading level="3">1. What is RapidXml?</heading>
</para><para>RapidXml is an attempt to create the fastest XML DOM parser possible, while retaining useability, portability and reasonable W3C compatibility. It is an in-situ parser written in C++, with parsing speed approaching that of <computeroutput>strlen()</computeroutput> function executed on the same data. Entire parser is contained in a single header file, so no building or linking is neccesary. To use it you just need to copy <computeroutput>rapidxml.hpp</computeroutput> file to a convenient place (such as your project directory), and include it where needed. <linebreak/>
<linebreak/>
 You may also want to use utilities contained in headers <computeroutput>rapidxml_print.hpp</computeroutput> and <computeroutput>rapidxml_utils.hpp</computeroutput>, although these are not documented.</para><para><heading level="4">Dependencies and compatibility</heading>
</para><para>RapidXml has <emphasis>no dependencies</emphasis> other than a very small subset of standard C++ library (namely <computeroutput>&lt;cassert&gt;</computeroutput>, <computeroutput>&lt;cstdlib&gt;</computeroutput> and <computeroutput>&lt;exception&gt;</computeroutput>, unless exceptions are disabled). It should compile on any reasonably conformant compiler, and was tested on Visual C++ 2003, Visual C++ 2005, gcc 3, gcc 4, and Comeau 4.3.3. Care has been taken that no warnings are produced on these compilers, even with highest warning levels enabled.</para><para><heading level="4">Character types and encodings</heading>
</para><para>RapidXml is character type agnostic, and can work both with narrow and wide characters. Current version only fully supports UTF-8, so use of wide characters is somewhat incapacitated. However, it should succesfully parse <computeroutput>wchar_t</computeroutput> strings containing UTF-16 or UTF-32 (depending on the wchar_t size), provided that endianness of the data matches that of the machine. This is often the case if data was loaded by use of standard library streams working in text mode.</para><para><heading level="4">Error handling</heading>
</para><para>By default, RapidXml uses C++ exceptions to report errors. If this behaviour is undesirable, RAPIDXML_NO_EXCEPTIONS can be defined to suppress exception code. See parse_error class and <ref refid="namespacerapidxml_ff5d67f74437199d316d2b2660653ae1_1ff5d67f74437199d316d2b2660653ae1" kindref="member">parse_error_handler()</ref> function for more information.</para><para><heading level="4">Memory allocation</heading>
</para><para>RapidXml uses a memory pool to allocate nodes and attributes. Underlying memory allocations performed by the pool can be customized by use of memory_pool::set_allocator() function. See class memory_pool for more information.</para><para><heading level="4">W3C compliance</heading>
</para><para>RapidXml is not a W3C compliant parser, primarily because it ignores DOCTYPE declarations. There is a number of other, minor incompatibilities as well. Still, it can successfully parse and produce complete trees of all valid XML files in W3C conformance suite (over 1000 files specially designed to find flaws in XML processors). In destructive mode it performs whitespace normalization and character entity substitution for a small set of built-in entities.</para><para><heading level="4">API</heading>
</para><para>RapidXml API is minimalistic, to reduce code size as much as possible, and facilitate use in embedded environments. Additional convenience functions are provided in separate headers: <computeroutput>rapidxml_utils.hpp</computeroutput> and <computeroutput>rapidxml_print.hpp</computeroutput>.</para><para><heading level="4">Reliability</heading>
</para><para>RapidXml is very robust and comes with a large harness of unit tests. Special care has been taken to ensure stability of the parser no matter what source text is thrown at it. One of the unit tests produces 100,000 randomly corrupted variants of XML document, which (when uncorrupted) contains all constructs recognized by RapidXml. RapidXml passes this test when it correctly recognizes that errors have been introduced, and does not crash or loop indefinitely. <linebreak/>
<linebreak/>
 Another unit test puts RapidXml head-to-head with another, well estabilished XML parser, and verifies that their outputs match across a wide variety of small and large documents. <linebreak/>
<linebreak/>
 Yet another test feeds RapidXml with over 1000 test files from W3C compliance suite, and verifies that correct results are obtained. There are also additional tests that verify each API function separately, and test that various parsing modes work as expected.</para><para><heading level="3">2. Two Minute Tutorial</heading>
</para><para>The following code causes RapidXml to parse a zero-terminated string named <computeroutput>text</computeroutput>: <computeroutput><linebreak/>
 <linebreak/>
using namespace rapidxml; <linebreak/>
xml_document&lt;char&gt; doc; <linebreak/>
doc.parse&lt;0&gt;(text); // 0 means default parse flags <linebreak/>
</computeroutput> <linebreak/>
 <computeroutput>doc</computeroutput> object is now a root of DOM tree containing representation of the parsed XML. Because all RapidXml interface is contained inside namespace <computeroutput>rapidxml</computeroutput>, users must either bring contents of this namespace into scope, or fully qualify all the names. Class xml_document represents a root of the DOM hierarchy. By means of public inheritance, it is also an xml_node and a memory_pool. Template parameter of xml_document::parse() function is used to specify parsing flags, with which you can fine-tune behaviour of the parser. Note that flags must be a compile-time constant. <linebreak/>
<linebreak/>
 To access the DOM tree, use methods of xml_node and xml_attribute classes: <computeroutput><linebreak/>
 <linebreak/>
std::cout &lt;&lt; &quot;My first node is: &quot; &lt;&lt; doc.first_node()-&gt;name() &lt;&lt; &quot;\n&quot;; <linebreak/>
xml_node&lt;char&gt; *node ? doc.first_node(&quot;foobar&quot;); <linebreak/>
std::cout &lt;&lt; &quot;Node foobar has value &quot; &lt;&lt; node-&gt;value() &lt;&lt; &quot;\n&quot;; <linebreak/>
xml_attribute&lt;char&gt; *attr ? node-&gt;first_attribute(); <linebreak/>
std::cout &lt;&lt; &quot;Node foobar has attribute &quot; &lt;&lt; attr-&gt;name() &lt;&lt; &quot;\n&quot;; <linebreak/>
std::cout &lt;&lt; &quot;...with value &quot; &lt;&lt; attr-&gt;value() &lt;&lt; &quot;\n&quot;; <linebreak/>
</computeroutput> <linebreak/>
 DOM tree produced by the parser is fully modifiable. Nodes and attributes can be added/removed, and their contents changed. The below example creates a HTML document, whose sole contents is a link to google.com website: <computeroutput><linebreak/>
 <linebreak/>
xml_document&lt;char&gt; doc; <linebreak/>
xml_node&lt;char&gt; *node ? doc.allocate_node(node_element); <linebreak/>
node-&gt;name(&quot;a&quot;); <linebreak/>
node-&gt;value(&quot;Google&quot;); <linebreak/>
doc.append_child(node); <linebreak/>
xml_attribute&lt;char&gt; *attr ? doc.allocate_attribute(); <linebreak/>
attr-&gt;name(&quot;href&quot;); <linebreak/>
attr-&gt;value(&quot;google.com&quot;); <linebreak/>
node-&gt;append_attribute(attr); <linebreak/>
</computeroutput> <linebreak/>
 One quirk is that nodes and attributes <emphasis>do not own</emphasis> the text of their names and values. This is because normally they only store pointers to the source text. So, when assigning a new name or value to the node, care must be taken to ensure proper lifetime of the string. The easiest way to achieve it is to allocate the string from the xml_document memory pool. In the above example this is not necessary, because we are only assigning character constants. But the code below uses memory_pool::allocate_string() function to allocate node name (which will have the same lifetime as the document), and assigns it to a new node: <computeroutput><linebreak/>
 <linebreak/>
xml_document&lt;char&gt; doc; <linebreak/>
char *node_name ? doc.allocate_string(strlen(name) + 1); <linebreak/>
strcpy(node_name, name); <linebreak/>
xml_node&lt;char&gt; *node ? doc.allocate_node(node_element); <linebreak/>
node-&gt;name(node_name); <linebreak/>
</computeroutput> <linebreak/>
 Check reference section for full description of the interface.</para><para><heading level="3">3. Why is it fast?</heading>
</para><para>RapidXml achieves its speed through use of several techniques:<itemizedlist>
<listitem><para>In-situ parsing. When building DOM tree, RapidXml does not make copies of string data, such as node names and values. Instead, it stores pointers to interior of the source text.</para></listitem><listitem><para>Use of template metaprogramming techniques. This allows it to move much of the work to compile time. Through magic of the templates, C++ compiler generates a separate copy of parsing code for any combination of parser flags you use. In each copy, all possible decisions are made at compile time and all unused code is omitted.</para></listitem><listitem><para>Extensive use of lookup tables for parsing.</para></listitem><listitem><para>Hand-tuned C++ with profiling done on several most popular CPUs.</para></listitem></itemizedlist>
</para><para>This results in a very small and fast code: a parser which is custom tailored to exact needs with each invocation. See &lt;a href?&quot;gogo&quot;&gt;performance charts for speed summary. <linebreak/>
<linebreak/>
 On the other hand, the performance has its cost. In-situ parsing requires that source text lives at least as long as the document object. Additionally, whitespace processing and entity reference translation require that source text be modified (but see non-destructive mode). This makes the text useless for further processing. In many cases however, these are not serious issues.</para><para><heading level="3">4. Destructive vs Nondestructive parsing</heading>
</para><para>Destructive or non-destructive mode is chosen by setting appropriate flags when calling xml_document::parse() function. <linebreak/>
<linebreak/>
 In non-destructive mode, the parser does not make any modifications to the source text. This is how a &quot;regular&quot; XML parser normally behaves. However, because RapidXml does in-situ parsing, forbidding source text modifications causes the following side-effects:<itemizedlist>
<listitem><para>No whitespace normalization is done.</para></listitem><listitem><para>No entity reference translation is done.</para></listitem><listitem><para>Names and values are not zero-terminated, you must use xml_base::name_size() and xml_base::value_size() functions to tell where they end.</para></listitem></itemizedlist>
</para><para>To alleviate these problems, destructive mode exists. In this mode, parser can modify source text, which allows it to perform the above transformations. Note that for this to work, memory where source text resides must be physically modifiable. For example, if it resides in a memory section protected by the operating system (such as read-only pages on Windows), it will cause the parser to generate segmentation fault when it tries to write to that memory.</para><para><heading level="3">5. Performance</heading>
</para><para>The table below compares speed of RapidXml to some other parsers, and to <computeroutput>strlen()</computeroutput> function executed on the same data. On modern CPU (as of 2007), you can expect parsing throughput to be close to 1 GB/s. As a rule of thumb, parsing speed is about 100x faster than Xerces DOM, 50x faster than TinyXml, 15x faster than pugxml, and about 10% - 30% faster than pugixml, the fastest XML parser I know of. <heading level="4">Test setup</heading>
</para><para><itemizedlist>
<listitem>
<para>The test file is 50kB large, moderately dense. </para></listitem>
<listitem>
<para>All timing was done by using RDTSC instruction present in Pentium-compatible CPUs. </para></listitem>
<listitem>
<para>No profile-guided optimizations were used. </para></listitem>
<listitem>
<para>All parsers are running in their fastest modes. </para></listitem>
<listitem>
<para>The results are given in CPU cycles per character, so frequency of CPUs is irrelevant. </para></listitem>
<listitem>
<para>The results are minimum values from a large number of runs, to minimize effects of operating system activity, task switching, interrupt handling etc. </para></listitem>
<listitem>
<para>A single parse of the test file takes about 1/10th of a millisecond, so with large number of runs there is good chance of hitting at least one no-interrupt streak, and obtaining undisturbed results. </para></listitem>
</itemizedlist>
<table rows="3" cols="7"><row>
<entry thead="yes"><para><center>Platform</center> </para></entry><entry thead="yes"><para><center>Compiler</center> </para></entry><entry thead="yes"><para>strlen() </para></entry><entry thead="yes"><para>RapidXml </para></entry><entry thead="yes"><para>pugixml </para></entry><entry thead="yes"><para>pugxml </para></entry><entry thead="yes"><para>TinyXml  </para></entry></row>
<row>
<entry thead="no"><para>Pentium 4 </para></entry><entry thead="no"><para>MSVC 8.0 </para></entry><entry thead="no"><para><center>2.6</center> </para></entry><entry thead="no"><para><center>6.4</center> </para></entry><entry thead="no"><para><center>9.9</center> </para></entry><entry thead="no"><para><center>79.2</center> </para></entry><entry thead="no"><para><center>326.8</center>  </para></entry></row>
<row>
<entry thead="no"><para>Pentium 4 </para></entry><entry thead="no"><para>gcc 4.1.1 </para></entry><entry thead="no"><para><center>1.1</center> </para></entry><entry thead="no"><para><center>6.7</center> </para></entry><entry thead="no"><para><center>11.5</center> </para></entry><entry thead="no"><para><center>85.5</center> </para></entry><entry thead="no"><para><center>460.4</center>  </para></entry></row>
</table>
<emphasis>(*) All numbers are in CPU cycles per character</emphasis> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
