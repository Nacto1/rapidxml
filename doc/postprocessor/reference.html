<html><body>
<h2>RapidXml Reference</h2>
<dl>
<dt>class
									template
								 <a href="#classrapidxml_1_1node__pool">node_pool</a>
</dt>
<dt>function <a href="#classrapidxml_1_1node__pool_2f55fe442d36e251ac2293eac7426544_12f55fe442d36e251ac2293eac7426544">node_pool()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1node__pool_6405579360b462555de1e8effa44c6e5_16405579360b462555de1e8effa44c6e5">~node_pool()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1node__pool_29d7103f6730cfce4aac5882e9c8dcb8_129d7103f6730cfce4aac5882e9c8dcb8">allocate_node(node_type type)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1node__pool_5e770a5afbf4f94db6dc3aef54c5758f_15e770a5afbf4f94db6dc3aef54c5758f">allocate_attribute()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1node__pool_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204">clear()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1node__pool_c0a55a6ef0837dca67572e357100d78a_1c0a55a6ef0837dca67572e357100d78a">set_allocator(alloc_func *af, free_func *ff)</a>
</dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<p></p>
<p></p>
<dt>class <a href="#classrapidxml_1_1parse__error">parse_error</a>
</dt>
<dt>function <a href="#classrapidxml_1_1parse__error_4dd8d1bdbd9221df4dcb90cafaee3332_14dd8d1bdbd9221df4dcb90cafaee3332">parse_error(const char *what, void *where)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1parse__error_ff06f49065b54a8a86e02e9a2441a8ba_1ff06f49065b54a8a86e02e9a2441a8ba">what() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1parse__error_377be7d201d95221c318682c35377aca_1377be7d201d95221c318682c35377aca">where() const </a>
</dt>
<dt></dt>
<dt></dt>
<p></p>
<dt>class
									template
								 <a href="#classrapidxml_1_1xml__attribute">xml_attribute</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__attribute_d5464aadf08269a886b730993525db34_1d5464aadf08269a886b730993525db34">xml_attribute()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__attribute_2b5c752353d5656348ec6b77f236e0ca_12b5c752353d5656348ec6b77f236e0ca">previous_attribute() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__attribute_9834f8040bbb25f39885d0dcf9f1582c_19834f8040bbb25f39885d0dcf9f1582c">previous_attribute(const Ch *name) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__attribute_ff31bf9e1f281fe76f4986f11f70e2cf_1ff31bf9e1f281fe76f4986f11f70e2cf">previous_attribute(const Ch *name, std::size_t name_size) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__attribute_8a89aa9486e932b933d8ac4d03d35eb9_18a89aa9486e932b933d8ac4d03d35eb9">next_attribute() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__attribute_4e2b64501e8ebd48f10008d1e4849f71_14e2b64501e8ebd48f10008d1e4849f71">next_attribute(const Ch *name) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__attribute_8df48174fb4c90079b2377cb1088c504_18df48174fb4c90079b2377cb1088c504">next_attribute(const Ch *name, std::size_t name_size) const </a>
</dt>
<dt></dt>
<dt></dt>
<dt></dt>
<p></p>
<dt>class
									template
								 <a href="#classrapidxml_1_1xml__base">xml_base</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__base_23630d2c130a9e0e3f3afa7584a9b218_123630d2c130a9e0e3f3afa7584a9b218">xml_base()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__base_622eade29fdf7806d3ef93ac4d90e707_1622eade29fdf7806d3ef93ac4d90e707">name() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__base_0dae694c8f7e4d89f1003e2f3a15a43c_10dae694c8f7e4d89f1003e2f3a15a43c">name_size() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__base_c54fa4987fb503916a7b541eb15c9c7f_1c54fa4987fb503916a7b541eb15c9c7f">value() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__base_aed5ae791b7164c1ee5e649198cbb3db_1aed5ae791b7164c1ee5e649198cbb3db">value_size() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__base_4e7e23d06d48126c65b1f6266acfba5c_14e7e23d06d48126c65b1f6266acfba5c">name(const Ch *name, std::size_t size)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__base_d9640aa3f5374673cb72a5289b6c91eb_1d9640aa3f5374673cb72a5289b6c91eb">value(const Ch *value, std::size_t size)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__base_798e8df7ea53ade4d9f0701017dce80e_1798e8df7ea53ade4d9f0701017dce80e">parent() const </a>
</dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<p></p>
<dt>class
									template
								 <a href="#classrapidxml_1_1xml__document">xml_document</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__document_6ce266cc52d549c42abe3a3d5e8af9ba_16ce266cc52d549c42abe3a3d5e8af9ba">xml_document()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__document_5bb2890c66aa91f84b6dd023ed3f9254_15bb2890c66aa91f84b6dd023ed3f9254">pool()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c">parse(Ch *text)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__document_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204">clear()</a>
</dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<dt>class
									template
								 <a href="#classrapidxml_1_1xml__node">xml_node</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_34c55af3504549a475e5b9dfcaa6adf5_134c55af3504549a475e5b9dfcaa6adf5">xml_node(node_type type)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_975e86937621ae4afe6a423219de30d0_1975e86937621ae4afe6a423219de30d0">type() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_054ed62d859241d3f8142e54f1a29eba_1054ed62d859241d3f8142e54f1a29eba">first_child() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_5a6c30e061d73c80eaa2592e1b05d174_15a6c30e061d73c80eaa2592e1b05d174">first_child(const Ch *name) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_fa356368ed48013003ab59cf541e47e2_1fa356368ed48013003ab59cf541e47e2">first_child(const Ch *name, std::size_t name_size) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_4dbdd521d6a4c0cf8d3dc2c7961b7e27_14dbdd521d6a4c0cf8d3dc2c7961b7e27">last_child() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_78c0c212a248ef361d7abec16f1723ca_178c0c212a248ef361d7abec16f1723ca">last_child(const Ch *name) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_ae4642bc0ae1a57d9e82a84b1642e8a2_1ae4642bc0ae1a57d9e82a84b1642e8a2">last_child(const Ch *name, std::size_t name_size) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_8a1c91dafcb517d134c17a539fbb6ace_18a1c91dafcb517d134c17a539fbb6ace">previous_sibling() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_5e29b7b99b6b4fbd466a618d2549f9fd_15e29b7b99b6b4fbd466a618d2549f9fd">previous_sibling(const Ch *name) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_3bceee1528f56dc159ab9ad4ebff34f1_13bceee1528f56dc159ab9ad4ebff34f1">previous_sibling(const Ch *name, std::size_t name_size) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_aef7e9648ba65548e99fac2656a28ec6_1aef7e9648ba65548e99fac2656a28ec6">next_sibling() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_8f7c7b56648ab90573168628ae7b53a0_18f7c7b56648ab90573168628ae7b53a0">next_sibling(const Ch *name) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_2f2a4b1509f7b2e5f736d1f8d90231ad_12f2a4b1509f7b2e5f736d1f8d90231ad">next_sibling(const Ch *name, std::size_t name_size) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_56a16fe6e7ba46dcfb7618819e2213d9_156a16fe6e7ba46dcfb7618819e2213d9">first_attribute() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_aebd5bce2a8feae83e21f8e82b098a31_1aebd5bce2a8feae83e21f8e82b098a31">first_attribute(const Ch *name) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_3fa6221329a3b235764c2439a0707c65_13fa6221329a3b235764c2439a0707c65">first_attribute(const Ch *name, std::size_t name_size) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_ed6c8c39b72dbb71a66e2e31128022ef_1ed6c8c39b72dbb71a66e2e31128022ef">last_attribute() const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_2c72aa5259f49609925aa1686d214f8b_12c72aa5259f49609925aa1686d214f8b">last_attribute(const Ch *name) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_287604244c856ae0427cf823ee7751e1_1287604244c856ae0427cf823ee7751e1">last_attribute(const Ch *name, std::size_t name_size) const </a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_a78759bfa429fa2ab6bc5fe617cfa3cf_1a78759bfa429fa2ab6bc5fe617cfa3cf">type(node_type type)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_bd710ef24d5088a7bfca8d318e23cf3f_1bd710ef24d5088a7bfca8d318e23cf3f">prepend_child(xml_node&lt; Ch &gt; *child)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_91cf07411c3b8c4ae5b317d07b39ee11_191cf07411c3b8c4ae5b317d07b39ee11">append_child(xml_node&lt; Ch &gt; *child)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_97ada639efe5492584ddf9c1e4efd88f_197ada639efe5492584ddf9c1e4efd88f">insert_child(xml_node&lt; Ch &gt; *where, xml_node&lt; Ch &gt; *child)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_9deec8583dadb51019d4ce3b053e83a3_19deec8583dadb51019d4ce3b053e83a3">remove_first_child()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_84fb0f4c4bc0c7cea321728f7ca2b02c_184fb0f4c4bc0c7cea321728f7ca2b02c">remove_last_child()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_45f32c32f8d0503cfa1c4fbcb8de6b47_145f32c32f8d0503cfa1c4fbcb8de6b47">remove_child(xml_node&lt; Ch &gt; *where)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_0755da49ff9b5b48759f9ba7151da00d_10755da49ff9b5b48759f9ba7151da00d">remove_all_children()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_f6dffa513da74cc0be71a7ba84f8265e_1f6dffa513da74cc0be71a7ba84f8265e">prepend_attribute(xml_attribute&lt; Ch &gt; *attribute)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_8fbd4f5ef7169d493da9f8d87ac04b77_18fbd4f5ef7169d493da9f8d87ac04b77">append_attribute(xml_attribute&lt; Ch &gt; *attribute)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_070d5888b0557fe06a5b24961de1b988_1070d5888b0557fe06a5b24961de1b988">insert_attribute(xml_attribute&lt; Ch &gt; *where, xml_attribute&lt; Ch &gt; *attribute)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_4eea4a7f6cb484ca9944f7eafe6e1843_14eea4a7f6cb484ca9944f7eafe6e1843">remove_first_attribute()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_37d87c4d5d89fa0cf05b72ee8d4cba3b_137d87c4d5d89fa0cf05b72ee8d4cba3b">remove_last_attribute()</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_c75154db2e768c0e5b541fc8cd0775ab_1c75154db2e768c0e5b541fc8cd0775ab">remove_attribute(xml_attribute&lt; Ch &gt; *where)</a>
</dt>
<dt>function <a href="#classrapidxml_1_1xml__node_59e6ad4cfd5e8096c052e71d79561eda_159e6ad4cfd5e8096c052e71d79561eda">remove_all_attributes()</a>
</dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<p></p>
<dt>namespace <a href="#namespacerapidxml"></a>
</dt>
<dt>enum <a href="#namespacerapidxml_6a276b85e2da28c5f9c3dbce61c55682_16a276b85e2da28c5f9c3dbce61c55682">node_type</a>
</dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt></dt>
<dt>
				constant
			 <a href="#namespacerapidxml_87ec54c61080b059ca1450ed510ce10c_187ec54c61080b059ca1450ed510ce10c">parse_no_declaration_node</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_87e8bbab53702cf3b438bd553c10b6b9_187e8bbab53702cf3b438bd553c10b6b9">parse_no_data_nodes</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_64ccf41a7dcab26b25dba79ddd8bffb4_164ccf41a7dcab26b25dba79ddd8bffb4">parse_no_comment_nodes</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_61d941922f7303c1f1041abacef57ffd_161d941922f7303c1f1041abacef57ffd">parse_no_doctype_node</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_beffb08c128d6251918e1ee6fac2e73d_1beffb08c128d6251918e1ee6fac2e73d">parse_no_pi_nodes</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_97e2c4fdc04fae17126f9971a4fc993e_197e2c4fdc04fae17126f9971a4fc993e">parse_no_element_values</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_9cae3801e70437cbc410c24bf6be691c_19cae3801e70437cbc410c24bf6be691c">parse_no_string_terminators</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_7223b7815c4fb8b42e6e4e77e1ea6b97_17223b7815c4fb8b42e6e4e77e1ea6b97">parse_no_entity_translation</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_a5daff9d61c7d4eaf98e4d42efe628ee_1a5daff9d61c7d4eaf98e4d42efe628ee">parse_validate_closing_tags</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_ac1f06b1afd47b812732fb521b146fd9_1ac1f06b1afd47b812732fb521b146fd9">parse_trim_whitespace</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_ccde57f6054857ee4042a1b4d98c83b9_1ccde57f6054857ee4042a1b4d98c83b9">parse_no_utf8</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_45751cf2f38fd6915f35b3122b46d5b6_145751cf2f38fd6915f35b3122b46d5b6">parse_default</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_a97ba1a0a79a6d66f4eef3612508d943_1a97ba1a0a79a6d66f4eef3612508d943">parse_non_destructive</a>
</dt>
<dt>
				constant
			 <a href="#namespacerapidxml_398c5476e76102f8bd76c10bb0abbe10_1398c5476e76102f8bd76c10bb0abbe10">parse_fastest</a>
</dt>
<p></p>
<p></p>
</dl>
<h3 id="classrapidxml_1_1node__pool">class
										template
									 rapidxml::node_pool</h3>
<h4>Include</h4>
								#include "<a href="../../rapidxml.hpp">rapidxml.hpp</a>
								"

								<h4>Parameters</h4>
<dl>
<dt>Ch</dt>
<dd>Character type of created nodes. </dd>
</dl>
<dl>
<dt>StaticBlockSize</dt>
<dd>Size of static memory block owned by the pool, in bytes. Pool is guaranteed not to make dynamic memory allocations until static memory block is exhausted. Using too large static block will cause stack overflow. </dd>
</dl>
<h4>Description</h4>
    This is an implementation of memory pool used by the parser to rapidly create new XML nodes. In most cases, you will not need to use it directly. However, if you need to create nodes manually, you are encouraged to use node_pool of relevant document to create the nodes. Not only is this faster than allocating them by using new operator, but also their lifetime will be tied to the lifetime of document, possibly simplyfing memory management. It is also possible to create a standalone pool, and use it to allocate nodes manually. Call allocate function to obtain a new XML node from the pool. Note that there is no free function -- all allocated nodes are freed at once when clear function is called, or when the pool is destroyed. Pools can use custom allocation/deallocation routines - use set_allocator function to set them. By default pool uses C++ new/delete operators. <p></p>
<h3 id="classrapidxml_1_1node__pool_2f55fe442d36e251ac2293eac7426544_12f55fe442d36e251ac2293eac7426544">function node_pool</h3>
<h4>Synopsis</h4>
<code>node_pool()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1node__pool_6405579360b462555de1e8effa44c6e5_16405579360b462555de1e8effa44c6e5">function ~node_pool</h3>
<h4>Synopsis</h4>
<code>~node_pool()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1node__pool_29d7103f6730cfce4aac5882e9c8dcb8_129d7103f6730cfce4aac5882e9c8dcb8">function allocate_node</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* allocate_node(node_type type)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Allocates a new node from the pool. If there is not enough free memory in the system, this function will throw std::bad_alloc <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of node to allocate. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to allocated node. This pointer will never be NULL. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>type</dt>
<dd>Type of node to allocate. </dd>
</dl>
<h4>Returns</h4>Pointer to allocated node. This pointer will never be NULL. <p></p>
<h3 id="classrapidxml_1_1node__pool_5e770a5afbf4f94db6dc3aef54c5758f_15e770a5afbf4f94db6dc3aef54c5758f">function allocate_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* allocate_attribute()
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Allocates a new attribute from the pool. If there is not enough free memory in the system, this function will throw std::bad_alloc <simplesect kind="return"><para>Pointer to allocated attribute. This pointer will never be NULL. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to allocated attribute. This pointer will never be NULL. <p></p>
<h3 id="classrapidxml_1_1node__pool_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204">function clear</h3>
<h4>Synopsis</h4>
<code>void clear()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1node__pool_c0a55a6ef0837dca67572e357100d78a_1c0a55a6ef0837dca67572e357100d78a">function set_allocator</h3>
<h4>Synopsis</h4>
<code>void set_allocator(alloc_func *af, free_func *ff)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Sets the memory allocation functions for the pool. This can only be called when no memory is allocated from the pool. Otherwise results are undefined. Allocation function must not return NULL on failure. It should either throw or stop the program. If it returns invalid pointer, results are undefined. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>af</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocation function, or 0 to restore default function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ff</parametername>
</parameternamelist>
<parameterdescription>
<para>Free function, or 0 to restore default function </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>af</dt>
<dd>Allocation function, or 0 to restore default function </dd>
</dl>
<dl>
<dt>ff</dt>
<dd>Free function, or 0 to restore default function </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1parse__error">class rapidxml::parse_error</h3>
<h4>Include</h4>
								#include "<a href="../../rapidxml.hpp">rapidxml.hpp</a>
								"

								<h4>Description</h4>
    Parse error exception. This exception is thrown by the parser when error occurs. Use <p></p>
<h3 id="classrapidxml_1_1parse__error_4dd8d1bdbd9221df4dcb90cafaee3332_14dd8d1bdbd9221df4dcb90cafaee3332">function parse_error</h3>
<h4>Synopsis</h4>
<code>parse_error(const char *what, void *where)
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1parse__error_ff06f49065b54a8a86e02e9a2441a8ba_1ff06f49065b54a8a86e02e9a2441a8ba">function what</h3>
<h4>Synopsis</h4>
<code>virtual const char* what() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets human readable description of error <simplesect kind="return"><para>Human readable description of the error </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Human readable description of the error <p></p>
<h3 id="classrapidxml_1_1parse__error_377be7d201d95221c318682c35377aca_1377be7d201d95221c318682c35377aca">function where</h3>
<h4>Synopsis</h4>
<code>Ch* where() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets pointer to character data where error happened Ch should be the same as char type of <ref refid="classrapidxml_1_1xml__document" kindref="compound">xml_document</ref> that produced the error <simplesect kind="return"><para>Pointer to location within the parsed string where error occured </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to location within the parsed string where error occured <p></p>
<h3 id="classrapidxml_1_1xml__attribute">class
										template
									 rapidxml::xml_attribute</h3>
<h4>Include</h4>
								#include "<a href="../../rapidxml.hpp">rapidxml.hpp</a>
								"

								<h4>Parameters</h4>
<dl>
<dt>Ch</dt>
<dd>Character type to use. </dd>
</dl>
<h4>Description</h4>
    Class representing attribute of XML document. Each attrbiute may have associated name and value strings, which are available through name and value functions. Note that after parse, both name and value of attribute will point to interior of source text used for parsing. This text must persist in memory for the lifetime of attrbiute, or undefined behavior occurs. <p></p>
<h3 id="classrapidxml_1_1xml__attribute_d5464aadf08269a886b730993525db34_1d5464aadf08269a886b730993525db34">function xml_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute()
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Constructs an empty attribute with the specified type. Consider using node_pool of appropriate document if allocating attributes manually. </para>
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__attribute_2b5c752353d5656348ec6b77f236e0ca_12b5c752353d5656348ec6b77f236e0ca">function previous_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* previous_attribute() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets previous attribute. Behaviour is undefined if attribute has no parent. <simplesect kind="return"><para>Pointer to previous sibling of attribute, or 0 if attribute has no previous sibling. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to previous sibling of attribute, or 0 if attribute has no previous sibling. <p></p>
<h3 id="classrapidxml_1_1xml__attribute_9834f8040bbb25f39885d0dcf9f1582c_19834f8040bbb25f39885d0dcf9f1582c">function previous_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* previous_attribute(const Ch *name) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds previous attribute with given name. Behaviour is undefined if attribute has no parent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of attribute to find, must be zero-terminated </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found attribute, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of attribute to find, must be zero-terminated </dd>
</dl>
<h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__attribute_ff31bf9e1f281fe76f4986f11f70e2cf_1ff31bf9e1f281fe76f4986f11f70e2cf">function previous_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* previous_attribute(const Ch *name, std::size_t name_size) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds previous attribute with given name. Behaviour is undefined if attribute has no parent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of attribute to find, doesn't have to be zero-terminated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found attribute, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of attribute to find, doesn't have to be zero-terminated </dd>
</dl>
<dl>
<dt>name_size</dt>
<dd>Size of name, in characters </dd>
</dl>
<h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__attribute_8a89aa9486e932b933d8ac4d03d35eb9_18a89aa9486e932b933d8ac4d03d35eb9">function next_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* next_attribute() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets next attribute. Behaviour is undefined if attribute has no parent. <simplesect kind="return"><para>Pointer to next sibling of attribute, or 0 if attribute has no next sibling. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to next sibling of attribute, or 0 if attribute has no next sibling. <p></p>
<h3 id="classrapidxml_1_1xml__attribute_4e2b64501e8ebd48f10008d1e4849f71_14e2b64501e8ebd48f10008d1e4849f71">function next_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* next_attribute(const Ch *name) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds next attribute with given name. Behaviour is undefined if attribute has no parent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of attribute to find, must be zero-terminated </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found attribute, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of attribute to find, must be zero-terminated </dd>
</dl>
<h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__attribute_8df48174fb4c90079b2377cb1088c504_18df48174fb4c90079b2377cb1088c504">function next_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* next_attribute(const Ch *name, std::size_t name_size) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds next attribute with given name. Behaviour is undefined if attribute has no parent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of attribute to find, doesn't have to be zero-terminated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found attribute, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of attribute to find, doesn't have to be zero-terminated </dd>
</dl>
<dl>
<dt>name_size</dt>
<dd>Size of name, in characters </dd>
</dl>
<h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__base">class
										template
									 rapidxml::xml_base</h3>
<h4>Include</h4>
								#include "<a href="../../rapidxml.hpp">rapidxml.hpp</a>
								"

								<h4>Parameters</h4>
<dl>
<dt>Ch</dt>
<dd>Character type to use </dd>
</dl>
<h4>Description</h4>
    Base class for nodes and attributes implementing common functionality: name, value and parent <p></p>
<h3 id="classrapidxml_1_1xml__base_23630d2c130a9e0e3f3afa7584a9b218_123630d2c130a9e0e3f3afa7584a9b218">function xml_base</h3>
<h4>Synopsis</h4>
<code>xml_base()
											;
											</code><p></p>
<h3 id="classrapidxml_1_1xml__base_622eade29fdf7806d3ef93ac4d90e707_1622eade29fdf7806d3ef93ac4d90e707">function name</h3>
<h4>Synopsis</h4>
<code>Ch* name() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets name of the node. Note that name will not be zero-terminated if parse_no_string_terminators option was selected during parse. <simplesect kind="return"><para>Name of node, or empty string if node has no name </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Name of node, or empty string if node has no name <p></p>
<h3 id="classrapidxml_1_1xml__base_0dae694c8f7e4d89f1003e2f3a15a43c_10dae694c8f7e4d89f1003e2f3a15a43c">function name_size</h3>
<h4>Synopsis</h4>
<code>std::size_t name_size() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets size of node name. If node has no name, results are undefined. <simplesect kind="return"><para>Size of node name, in characters </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Size of node name, in characters <p></p>
<h3 id="classrapidxml_1_1xml__base_c54fa4987fb503916a7b541eb15c9c7f_1c54fa4987fb503916a7b541eb15c9c7f">function value</h3>
<h4>Synopsis</h4>
<code>Ch* value() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets value of node. note that value will not be zero-terminated if parse_no_string_terminators option was selected during parse. <simplesect kind="return"><para>Value of node, or empty string if node has no value </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Value of node, or empty string if node has no value <p></p>
<h3 id="classrapidxml_1_1xml__base_aed5ae791b7164c1ee5e649198cbb3db_1aed5ae791b7164c1ee5e649198cbb3db">function value_size</h3>
<h4>Synopsis</h4>
<code>std::size_t value_size() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets size of node value. If node has no value, results are undefined. <simplesect kind="return"><para>Size of node value, in characters </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Size of node value, in characters <p></p>
<h3 id="classrapidxml_1_1xml__base_4e7e23d06d48126c65b1f6266acfba5c_14e7e23d06d48126c65b1f6266acfba5c">function name</h3>
<h4>Synopsis</h4>
<code>void name(const Ch *name, std::size_t size)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of node to set </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of node to set </dd>
</dl>
<dl>
<dt>size</dt>
<dd>Size of name, in characters </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__base_d9640aa3f5374673cb72a5289b6c91eb_1d9640aa3f5374673cb72a5289b6c91eb">function value</h3>
<h4>Synopsis</h4>
<code>void value(const Ch *value, std::size_t size)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Value of node to set </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of value, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>value</dt>
<dd>Value of node to set </dd>
</dl>
<dl>
<dt>size</dt>
<dd>Size of value, in characters </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__base_798e8df7ea53ade4d9f0701017dce80e_1798e8df7ea53ade4d9f0701017dce80e">function parent</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* parent() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets node parent <simplesect kind="return"><para>Pointer to parent node, or 0 if node has no parent. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to parent node, or 0 if node has no parent. <p></p>
<h3 id="classrapidxml_1_1xml__document">class
										template
									 rapidxml::xml_document</h3>
<h4>Include</h4>
								#include "<a href="../../rapidxml.hpp">rapidxml.hpp</a>
								"

								<h4>Parameters</h4>
<dl>
<dt>Ch</dt>
<dd>character type to use </dd>
</dl>
<dl>
<dt>StaticBlockSize</dt>
<dd>size of static block to use for allocating nodes; no dynamic memory allocations occur until this block is exhausted </dd>
</dl>
<h4>Description</h4>
    XML document <p></p>
<h3 id="classrapidxml_1_1xml__document_6ce266cc52d549c42abe3a3d5e8af9ba_16ce266cc52d549c42abe3a3d5e8af9ba">function xml_document</h3>
<h4>Synopsis</h4>
<code>xml_document()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__document_5bb2890c66aa91f84b6dd023ed3f9254_15bb2890c66aa91f84b6dd023ed3f9254">function pool</h3>
<h4>Synopsis</h4>
<code>node_pool&lt;Ch, StaticBlockSize&gt;&amp; pool()
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets memory pool of document. This pool is used by the parser to allocate new nodes. <simplesect kind="return"><para>Memory pool of document. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Memory pool of document. <p></p>
<h3 id="classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c">function parse</h3>
<h4>Synopsis</h4>
<code>void parse(Ch *text)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parses XML data according to given flags Passed data will be modified by the parser (unless parse_non_destructive flag is used) and must persist for the lifetime of parser <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>text</parametername>
</parameternamelist>
<parameterdescription>
<para>XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>text</dt>
<dd>XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__document_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204">function clear</h3>
<h4>Synopsis</h4>
<code>void clear()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__node">class
										template
									 rapidxml::xml_node</h3>
<h4>Include</h4>
								#include "<a href="../../rapidxml.hpp">rapidxml.hpp</a>
								"

								<h4>Parameters</h4>
<dl>
<dt>Ch</dt>
<dd>Character type to use. </dd>
</dl>
<h4>Description</h4>
    Class representing node of XML document. Each node may have associated name and value strings, which are available through name and value functions. Type of node can be determined by using type function. Note that after parse, both name and value of node, if any, will point interior of source text used for parsing. This text must persist in memory for the lifetime of node, or undefined behavior occurs. <p></p>
<h3 id="classrapidxml_1_1xml__node_34c55af3504549a475e5b9dfcaa6adf5_134c55af3504549a475e5b9dfcaa6adf5">function xml_node</h3>
<h4>Synopsis</h4>
<code>xml_node(node_type type)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Constructs an empty node with the specified type. Consider using node_pool of appropriate document to allocate nodes manually. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of node to construct. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>type</dt>
<dd>Type of node to construct. </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_975e86937621ae4afe6a423219de30d0_1975e86937621ae4afe6a423219de30d0">function type</h3>
<h4>Synopsis</h4>
<code>node_type type() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets type of node <simplesect kind="return"><para>Type of node </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Type of node <p></p>
<h3 id="classrapidxml_1_1xml__node_054ed62d859241d3f8142e54f1a29eba_1054ed62d859241d3f8142e54f1a29eba">function first_child</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* first_child() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets first child of node <simplesect kind="return"><para>Pointer to first child of node, or 0 if node has no children. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to first child of node, or 0 if node has no children. <p></p>
<h3 id="classrapidxml_1_1xml__node_5a6c30e061d73c80eaa2592e1b05d174_15a6c30e061d73c80eaa2592e1b05d174">function first_child</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* first_child(const Ch *name) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds first child of node with given name <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of child to find, must be zero-terminated </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found child of node, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of child to find, must be zero-terminated </dd>
</dl>
<h4>Returns</h4>Pointer to found child of node, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_fa356368ed48013003ab59cf541e47e2_1fa356368ed48013003ab59cf541e47e2">function first_child</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* first_child(const Ch *name, std::size_t name_size) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds first child of node with given name <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of child to find, doesn't have to be zero-terminated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found child of node, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of child to find, doesn't have to be zero-terminated </dd>
</dl>
<dl>
<dt>name_size</dt>
<dd>Size of name, in characters </dd>
</dl>
<h4>Returns</h4>Pointer to found child of node, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_4dbdd521d6a4c0cf8d3dc2c7961b7e27_14dbdd521d6a4c0cf8d3dc2c7961b7e27">function last_child</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* last_child() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets last child of node. Behaviour is undefined if node has no children. Use first_child to test if node has children. <simplesect kind="return"><para>Pointer to last child of node. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to last child of node. <p></p>
<h3 id="classrapidxml_1_1xml__node_78c0c212a248ef361d7abec16f1723ca_178c0c212a248ef361d7abec16f1723ca">function last_child</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* last_child(const Ch *name) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds last child of node with given name. Behaviour is undefined if node has no children. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of child to find, must be zero-terminated </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found child of node, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of child to find, must be zero-terminated </dd>
</dl>
<h4>Returns</h4>Pointer to found child of node, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_ae4642bc0ae1a57d9e82a84b1642e8a2_1ae4642bc0ae1a57d9e82a84b1642e8a2">function last_child</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* last_child(const Ch *name, std::size_t name_size) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds last child of node with given name. Behaviour is undefined if node has no children. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of child to find, doesn't have to be zero-terminated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found child of node, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of child to find, doesn't have to be zero-terminated </dd>
</dl>
<dl>
<dt>name_size</dt>
<dd>Size of name, in characters </dd>
</dl>
<h4>Returns</h4>Pointer to found child of node, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_8a1c91dafcb517d134c17a539fbb6ace_18a1c91dafcb517d134c17a539fbb6ace">function previous_sibling</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* previous_sibling() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets previous sibling of node. Behaviour is undefined if node has no parent. <simplesect kind="return"><para>Pointer to previous sibling of node, or 0 if node has no previous sibling. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to previous sibling of node, or 0 if node has no previous sibling. <p></p>
<h3 id="classrapidxml_1_1xml__node_5e29b7b99b6b4fbd466a618d2549f9fd_15e29b7b99b6b4fbd466a618d2549f9fd">function previous_sibling</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* previous_sibling(const Ch *name) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds previous sibling of node with given name. Behaviour is undefined if node has no parent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of sibling to find, must be zero-terminated </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found sibling of node, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of sibling to find, must be zero-terminated </dd>
</dl>
<h4>Returns</h4>Pointer to found sibling of node, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_3bceee1528f56dc159ab9ad4ebff34f1_13bceee1528f56dc159ab9ad4ebff34f1">function previous_sibling</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* previous_sibling(const Ch *name, std::size_t name_size) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds previous sibling of node with given name. Behaviour is undefined if node has no parent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of sibling to find, doesn't have to be zero-terminated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found sibling of node, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of sibling to find, doesn't have to be zero-terminated </dd>
</dl>
<dl>
<dt>name_size</dt>
<dd>Size of name, in characters </dd>
</dl>
<h4>Returns</h4>Pointer to found sibling of node, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_aef7e9648ba65548e99fac2656a28ec6_1aef7e9648ba65548e99fac2656a28ec6">function next_sibling</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* next_sibling() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets next sibling of node. Behaviour is undefined if node has no parent. <simplesect kind="return"><para>Pointer to next sibling of node, or 0 if node has no next sibling. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to next sibling of node, or 0 if node has no next sibling. <p></p>
<h3 id="classrapidxml_1_1xml__node_8f7c7b56648ab90573168628ae7b53a0_18f7c7b56648ab90573168628ae7b53a0">function next_sibling</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* next_sibling(const Ch *name) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds next sibling of node with given name. Behaviour is undefined if node has no parent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of sibling to find, must be zero-terminated </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found sibling of node, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of sibling to find, must be zero-terminated </dd>
</dl>
<h4>Returns</h4>Pointer to found sibling of node, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_2f2a4b1509f7b2e5f736d1f8d90231ad_12f2a4b1509f7b2e5f736d1f8d90231ad">function next_sibling</h3>
<h4>Synopsis</h4>
<code>xml_node&lt;Ch&gt;* next_sibling(const Ch *name, std::size_t name_size) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds next sibling of node with given name. Behaviour is undefined if node has no parent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of sibling to find, doesn't have to be zero-terminated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found sibling of node, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of sibling to find, doesn't have to be zero-terminated </dd>
</dl>
<dl>
<dt>name_size</dt>
<dd>Size of name, in characters </dd>
</dl>
<h4>Returns</h4>Pointer to found sibling of node, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_56a16fe6e7ba46dcfb7618819e2213d9_156a16fe6e7ba46dcfb7618819e2213d9">function first_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* first_attribute() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets first attribute of node <simplesect kind="return"><para>Pointer to first attribute of node, or 0 if node has no attributes. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to first attribute of node, or 0 if node has no attributes. <p></p>
<h3 id="classrapidxml_1_1xml__node_aebd5bce2a8feae83e21f8e82b098a31_1aebd5bce2a8feae83e21f8e82b098a31">function first_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* first_attribute(const Ch *name) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds first attribute of node with given name <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of attribute to find, must be zero-terminated </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found attribute, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of attribute to find, must be zero-terminated </dd>
</dl>
<h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_3fa6221329a3b235764c2439a0707c65_13fa6221329a3b235764c2439a0707c65">function first_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* first_attribute(const Ch *name, std::size_t name_size) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds first attribute of node with given name <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of attribute to find, doesn't have to be zero-terminated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found attribute, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of attribute to find, doesn't have to be zero-terminated </dd>
</dl>
<dl>
<dt>name_size</dt>
<dd>Size of name, in characters </dd>
</dl>
<h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_ed6c8c39b72dbb71a66e2e31128022ef_1ed6c8c39b72dbb71a66e2e31128022ef">function last_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* last_attribute() const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets last attribute of node. Behaviour is undefined if node has no attributes. Use first_attribute to test if node has attributes. <simplesect kind="return"><para>Pointer to last attribute of node. </para></simplesect>
</para>
										}ww
										
										<h4>Returns</h4>Pointer to last attribute of node. <p></p>
<h3 id="classrapidxml_1_1xml__node_2c72aa5259f49609925aa1686d214f8b_12c72aa5259f49609925aa1686d214f8b">function last_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* last_attribute(const Ch *name) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds last attribute of node with given name. Behaviour is undefined if node has no attributes. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of attribute to find, must be zero-terminated </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found attribute, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of attribute to find, must be zero-terminated </dd>
</dl>
<h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_287604244c856ae0427cf823ee7751e1_1287604244c856ae0427cf823ee7751e1">function last_attribute</h3>
<h4>Synopsis</h4>
<code>xml_attribute&lt;Ch&gt;* last_attribute(const Ch *name, std::size_t name_size) const 
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Finds last attribute of node with given name. Behaviour is undefined if node has no attributes. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of attribute to find, doesn't have to be zero-terminated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of name, in characters </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to found attribute, or 0 if not found. </para></simplesect>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>name</dt>
<dd>Name of attribute to find, doesn't have to be zero-terminated </dd>
</dl>
<dl>
<dt>name_size</dt>
<dd>Size of name, in characters </dd>
</dl>
<h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p></p>
<h3 id="classrapidxml_1_1xml__node_a78759bfa429fa2ab6bc5fe617cfa3cf_1a78759bfa429fa2ab6bc5fe617cfa3cf">function type</h3>
<h4>Synopsis</h4>
<code>void type(node_type type)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Sets type of node <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of node to set </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>type</dt>
<dd>Type of node to set </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_bd710ef24d5088a7bfca8d318e23cf3f_1bd710ef24d5088a7bfca8d318e23cf3f">function prepend_child</h3>
<h4>Synopsis</h4>
<code>void prepend_child(xml_node&lt; Ch &gt; *child)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Prepends a new child to the node. The prepended child becomes the first child, and all existing children are moved one position back. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>child</parametername>
</parameternamelist>
<parameterdescription>
<para>Node to prepend </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>child</dt>
<dd>Node to prepend </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_91cf07411c3b8c4ae5b317d07b39ee11_191cf07411c3b8c4ae5b317d07b39ee11">function append_child</h3>
<h4>Synopsis</h4>
<code>void append_child(xml_node&lt; Ch &gt; *child)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Appends a new child to the node. The appended child becomes the last child. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>child</parametername>
</parameternamelist>
<parameterdescription>
<para>Node to append </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>child</dt>
<dd>Node to append </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_97ada639efe5492584ddf9c1e4efd88f_197ada639efe5492584ddf9c1e4efd88f">function insert_child</h3>
<h4>Synopsis</h4>
<code>void insert_child(xml_node&lt; Ch &gt; *where, xml_node&lt; Ch &gt; *child)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Inserts a new child at specified place inside the node. All children after and including the specified node are moved one position back. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>where</parametername>
</parameternamelist>
<parameterdescription>
<para>Place where to insert the child, or 0 to insert at the back </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>child</parametername>
</parameternamelist>
<parameterdescription>
<para>Node to insert </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>where</dt>
<dd>Place where to insert the child, or 0 to insert at the back </dd>
</dl>
<dl>
<dt>child</dt>
<dd>Node to insert </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_9deec8583dadb51019d4ce3b053e83a3_19deec8583dadb51019d4ce3b053e83a3">function remove_first_child</h3>
<h4>Synopsis</h4>
<code>void remove_first_child()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__node_84fb0f4c4bc0c7cea321728f7ca2b02c_184fb0f4c4bc0c7cea321728f7ca2b02c">function remove_last_child</h3>
<h4>Synopsis</h4>
<code>void remove_last_child()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__node_45f32c32f8d0503cfa1c4fbcb8de6b47_145f32c32f8d0503cfa1c4fbcb8de6b47">function remove_child</h3>
<h4>Synopsis</h4>
<code>void remove_child(xml_node&lt; Ch &gt; *where)
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__node_0755da49ff9b5b48759f9ba7151da00d_10755da49ff9b5b48759f9ba7151da00d">function remove_all_children</h3>
<h4>Synopsis</h4>
<code>void remove_all_children()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__node_f6dffa513da74cc0be71a7ba84f8265e_1f6dffa513da74cc0be71a7ba84f8265e">function prepend_attribute</h3>
<h4>Synopsis</h4>
<code>void prepend_attribute(xml_attribute&lt; Ch &gt; *attribute)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Prepends a new attribute to the node <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>attribute</parametername>
</parameternamelist>
<parameterdescription>
<para>Attribute to prepend </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>attribute</dt>
<dd>Attribute to prepend </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_8fbd4f5ef7169d493da9f8d87ac04b77_18fbd4f5ef7169d493da9f8d87ac04b77">function append_attribute</h3>
<h4>Synopsis</h4>
<code>void append_attribute(xml_attribute&lt; Ch &gt; *attribute)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Appends a new attribute to the node <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>attribute</parametername>
</parameternamelist>
<parameterdescription>
<para>Attribute to append </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>attribute</dt>
<dd>Attribute to append </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_070d5888b0557fe06a5b24961de1b988_1070d5888b0557fe06a5b24961de1b988">function insert_attribute</h3>
<h4>Synopsis</h4>
<code>void insert_attribute(xml_attribute&lt; Ch &gt; *where, xml_attribute&lt; Ch &gt; *attribute)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Inserts a new attribute at specified place inside the node. All attributes after and including the specified attribute are moved one position back. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>where</parametername>
</parameternamelist>
<parameterdescription>
<para>Place where to insert the attribute, or 0 to insert at the back </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>attribute</parametername>
</parameternamelist>
<parameterdescription>
<para>Attribute to insert </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>where</dt>
<dd>Place where to insert the attribute, or 0 to insert at the back </dd>
</dl>
<dl>
<dt>attribute</dt>
<dd>Attribute to insert </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_4eea4a7f6cb484ca9944f7eafe6e1843_14eea4a7f6cb484ca9944f7eafe6e1843">function remove_first_attribute</h3>
<h4>Synopsis</h4>
<code>void remove_first_attribute()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__node_37d87c4d5d89fa0cf05b72ee8d4cba3b_137d87c4d5d89fa0cf05b72ee8d4cba3b">function remove_last_attribute</h3>
<h4>Synopsis</h4>
<code>void remove_last_attribute()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="classrapidxml_1_1xml__node_c75154db2e768c0e5b541fc8cd0775ab_1c75154db2e768c0e5b541fc8cd0775ab">function remove_attribute</h3>
<h4>Synopsis</h4>
<code>void remove_attribute(xml_attribute&lt; Ch &gt; *where)
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes specified attribute from node <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>where</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to attribute to be removed </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>
										}ww
										
										<h4>Parameters</h4>
<dl>
<dt>where</dt>
<dd>Pointer to attribute to be removed </dd>
</dl>
<p></p>
<h3 id="classrapidxml_1_1xml__node_59e6ad4cfd5e8096c052e71d79561eda_159e6ad4cfd5e8096c052e71d79561eda">function remove_all_attributes</h3>
<h4>Synopsis</h4>
<code>void remove_all_attributes()
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_6a276b85e2da28c5f9c3dbce61c55682_16a276b85e2da28c5f9c3dbce61c55682">enum node_type</h3>
<h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Enumeration of all XML nodes produced by the parser. Use <ref refid="classrapidxml_1_1xml__node_975e86937621ae4afe6a423219de30d0_1975e86937621ae4afe6a423219de30d0" kindref="member">xml_node&lt;Ch&gt;::type()</ref> function to query node type. </para>
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_87ec54c61080b059ca1450ed510ce10c_187ec54c61080b059ca1450ed510ce10c">
				constant
			 parse_no_declaration_node</h3>
<h4>Synopsis</h4>
<code>const int parse_no_declaration_node
												= 0x1
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_87e8bbab53702cf3b438bd553c10b6b9_187e8bbab53702cf3b438bd553c10b6b9">
				constant
			 parse_no_data_nodes</h3>
<h4>Synopsis</h4>
<code>const int parse_no_data_nodes
												= 0x2
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_64ccf41a7dcab26b25dba79ddd8bffb4_164ccf41a7dcab26b25dba79ddd8bffb4">
				constant
			 parse_no_comment_nodes</h3>
<h4>Synopsis</h4>
<code>const int parse_no_comment_nodes
												= 0x4
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_61d941922f7303c1f1041abacef57ffd_161d941922f7303c1f1041abacef57ffd">
				constant
			 parse_no_doctype_node</h3>
<h4>Synopsis</h4>
<code>const int parse_no_doctype_node
												= 0x8
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_beffb08c128d6251918e1ee6fac2e73d_1beffb08c128d6251918e1ee6fac2e73d">
				constant
			 parse_no_pi_nodes</h3>
<h4>Synopsis</h4>
<code>const int parse_no_pi_nodes
												= 0x10
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_97e2c4fdc04fae17126f9971a4fc993e_197e2c4fdc04fae17126f9971a4fc993e">
				constant
			 parse_no_element_values</h3>
<h4>Synopsis</h4>
<code>const int parse_no_element_values
												= 0x20
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_9cae3801e70437cbc410c24bf6be691c_19cae3801e70437cbc410c24bf6be691c">
				constant
			 parse_no_string_terminators</h3>
<h4>Synopsis</h4>
<code>const int parse_no_string_terminators
												= 0x40
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_7223b7815c4fb8b42e6e4e77e1ea6b97_17223b7815c4fb8b42e6e4e77e1ea6b97">
				constant
			 parse_no_entity_translation</h3>
<h4>Synopsis</h4>
<code>const int parse_no_entity_translation
												= 0x80
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_a5daff9d61c7d4eaf98e4d42efe628ee_1a5daff9d61c7d4eaf98e4d42efe628ee">
				constant
			 parse_validate_closing_tags</h3>
<h4>Synopsis</h4>
<code>const int parse_validate_closing_tags
												= 0x100
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_ac1f06b1afd47b812732fb521b146fd9_1ac1f06b1afd47b812732fb521b146fd9">
				constant
			 parse_trim_whitespace</h3>
<h4>Synopsis</h4>
<code>const int parse_trim_whitespace
												= 0x200
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_ccde57f6054857ee4042a1b4d98c83b9_1ccde57f6054857ee4042a1b4d98c83b9">
				constant
			 parse_no_utf8</h3>
<h4>Synopsis</h4>
<code>const int parse_no_utf8
												= 0x400
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_45751cf2f38fd6915f35b3122b46d5b6_145751cf2f38fd6915f35b3122b46d5b6">
				constant
			 parse_default</h3>
<h4>Synopsis</h4>
<code>const int parse_default
												= 0
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">A combination of parse flags which represent default behaviour of the parser. This is always equal to 0, so that options can be simply or'ed together. Normally there is no need to inconveniently 'disable' flags by and'ing with their negated values. </para>
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_a97ba1a0a79a6d66f4eef3612508d943_1a97ba1a0a79a6d66f4eef3612508d943">
				constant
			 parse_non_destructive</h3>
<h4>Synopsis</h4>
<code>const int parse_non_destructive
												= parse_no_string_terminators | parse_no_entity_translation
											;
											</code><h4>Description</h4>

										ww{
										<para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">A combination of parse flags that forbids any modifications of the source text. This also results in faster parsing. However, note that the following will occur: <itemizedlist>
<listitem>
<para>Names and values of nodes will not be zero terminated. You have to use name_size() and value_size() functions to determine where name and value ends. </para></listitem>
<listitem>
<para>Entities will not be translated. </para></listitem>
</itemizedlist>
</para>
										}ww
										
										<p></p>
<h3 id="namespacerapidxml_398c5476e76102f8bd76c10bb0abbe10_1398c5476e76102f8bd76c10bb0abbe10">
				constant
			 parse_fastest</h3>
<h4>Synopsis</h4>
<code>const int parse_fastest
												= parse_non_destructive | parse_no_declaration_node | parse_no_data_nodes | parse_no_doctype_node | parse_no_pi_nodes
											;
											</code><h4>Description</h4>

										ww{
										
										}ww
										
										<p></p>
</body></html>
